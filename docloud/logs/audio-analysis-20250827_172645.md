# Audio Engine Analysis for Mandala Visualization
**Timestamp**: 2025-08-27 17:26:45  
**Agent**: Web Audio API and Digital Signal Processing Specialist  
**Target**: Mandala visualization requirements assessment

## Status
```yaml
status: SUCCESS
summary: Complete audio engine analysis performed for mandala rendering requirements
details: Analyzed current frequency analysis capabilities, performance characteristics, and optimization opportunities
metrics: [FFT: 2048, Bins: 1024, Smoothing: 0.8, Gain: 0.1-5.0]
next: Provide optimization recommendations for radial frequency mapping
context: Current linear bar renderer needs radial transformation for mandala patterns
```

## 1. Current Frequency Analysis Capabilities

### FFT Configuration
- **FFT Size**: Fixed at 2048 samples
- **Frequency Bins**: 1024 bins available (fftSize/2)
- **Sample Rate**: Depends on AudioContext (typically 44.1kHz or 48kHz)
- **Frequency Resolution**: ~21.5Hz per bin at 44.1kHz (44100/2048)
- **Nyquist Frequency**: ~22kHz maximum

### Analysis Node Configuration
```typescript
// Current settings from audioEngine.ts:
analyser.fftSize = 2048;                    // Fixed size
analyser.smoothingTimeConstant = 0.8;       // Heavy smoothing
analyser.getByteFrequencyData(target);      // 0-255 range output
```

### Data Extraction
- **Output Format**: Uint8Array with 0-255 range
- **Update Method**: `readFrequencyData(target: Uint8Array)`
- **Zero-allocation**: Reuses pre-allocated array
- **Real-time**: Updates on every requestAnimationFrame

## 2. Performance Characteristics and Optimization Opportunities

### Current Performance Profile
- **Frame Budget**: 12ms render budget enforced in renderer
- **Memory Allocation**: Pre-allocated Uint8Array, zero-allocation in hot path
- **Smoothing**: Heavy smoothing (0.8) reduces temporal noise but adds latency
- **Processing Overhead**: Minimal - single `getByteFrequencyData()` call

### Performance Bottlenecks Identified
1. **Fixed FFT Size**: 2048 may be excessive for mandala rendering
2. **Linear Bar Mapping**: Current logarithmic mapping optimized for linear bars
3. **Single Resolution**: No adaptive quality based on performance
4. **Heavy Smoothing**: 0.8 smoothing may blur transient audio events

### Optimization Opportunities
```typescript
// Recommended improvements for mandala visualization:

// 1. Adaptive FFT sizing based on detail requirements
const MANDALA_FFT_SIZES = {
  low: 1024,     // 512 bins, good for mobile/low-detail
  medium: 2048,  // 1024 bins, current performance
  high: 4096,    // 2048 bins, for high-detail mandala
  ultra: 8192    // 4096 bins, for premium desktop experience
};

// 2. Reduced smoothing for more dynamic mandalas
const MANDALA_SMOOTHING = 0.6; // vs current 0.8

// 3. Selective frequency range focus
const MANDALA_FREQ_RANGE = {
  minBin: 1,    // Skip DC component
  maxBin: 800,  // Focus on musical frequencies (0-17kHz at 44.1kHz)
};
```

## 3. Data Structures Used for Frequency Data

### Current Structure
```typescript
// From audioEngine.ts:
private frequencyBins: Uint8Array | null = null;

// Allocation in constructor:
this.frequencyBins = new Uint8Array(this.analyser.frequencyBinCount);

// Usage in main.ts:
this.frequencyData = new Uint8Array(new ArrayBuffer(binCount));
```

### Characteristics
- **Type**: Uint8Array (8-bit unsigned integers)
- **Range**: 0-255 (logarithmic dB scale, typically -100dB to 0dB)
- **Size**: 1024 elements at current 2048 FFT
- **Memory**: ~1KB per frame buffer
- **Persistence**: Single buffer, overwritten each frame

### Mandala-Optimized Data Structure Recommendations
```typescript
// Enhanced data structure for mandala rendering:
interface MandalaFrequencyData {
  // Raw frequency bins
  rawBins: Uint8Array;           // Original 0-255 data
  
  // Radial mapping data
  radialBands: Float32Array;     // Normalized 0.0-1.0 for rings
  angularSectors: Float32Array;  // Frequency distribution per angle
  
  // Analysis metadata
  peakFrequency: number;         // Current dominant frequency
  totalEnergy: number;           // RMS energy level
  spectralCentroid: number;      // Perceived brightness
  
  // Performance metrics
  analysisTime: number;          // Processing overhead tracking
}
```

## 4. Current Frequency Bin Distribution

### Linear Distribution (Raw FFT)
- **Bin 0**: DC component (0 Hz) - unused
- **Bin 1-1024**: Linear frequency spacing
- **Spacing**: ~21.5 Hz per bin at 44.1kHz
- **Range**: 0 Hz to ~22 kHz

### Current Logarithmic Mapping (renderer.ts)
```typescript
// Current bar renderer uses logarithmic mapping:
const logPos = (i / (this.barCount - 1)) * logRange + logMinFreq;
const logFreqIndex = Math.round(Math.exp(logPos));

// This compresses high frequencies and expands low frequencies
// Good for linear bar charts, needs adaptation for radial display
```

### Frequency Distribution Analysis
- **Low Frequencies (20-250 Hz)**: Bass, kicks - ~11 bins
- **Mid Frequencies (250-4000 Hz)**: Vocals, melody - ~180 bins  
- **High Frequencies (4000-22000 Hz)**: Harmonics, cymbals - ~833 bins
- **Musical Focus**: Most energy typically in 80-8000 Hz range

## 5. Requirements for Mandala Rendering (Radial Frequency Mapping)

### Radial Ring Requirements
```typescript
// Mandala requires concentric rings for frequency bands:
const MANDALA_RING_CONFIG = {
  ringCount: 8,              // Number of concentric frequency rings
  innerRadius: 50,           // Center exclusion zone
  outerRadius: 300,          // Maximum visualization radius
  ringSpacing: 'logarithmic' // Even perceptual distribution
};

// Frequency band mapping for rings:
const FREQUENCY_BANDS = [
  { name: 'sub-bass',    range: [20, 60],    ring: 0 },
  { name: 'bass',        range: [60, 250],   ring: 1 },
  { name: 'low-mid',     range: [250, 500],  ring: 2 },
  { name: 'mid',         range: [500, 2000], ring: 3 },
  { name: 'high-mid',    range: [2000, 4000], ring: 4 },
  { name: 'presence',    range: [4000, 6000], ring: 5 },
  { name: 'brilliance', range: [6000, 12000], ring: 6 },
  { name: 'air',        range: [12000, 22000], ring: 7 }
];
```

### Angular Sector Requirements
```typescript
// Mandala requires angular sectors for temporal/harmonic analysis:
const MANDALA_SECTOR_CONFIG = {
  sectorCount: 64,           // Angular divisions (2π/64 = ~5.6° each)
  rotationSpeed: 0.02,       // Radians per frame for rotation effect
  symmetryMode: 'radial-4',  // 4-fold radial symmetry option
  phaseOffset: 0             // Starting angle offset
};
```

### Performance Requirements for Mandala
1. **Frame Rate**: 60fps target, 30fps minimum
2. **Latency**: <20ms audio-to-visual delay
3. **Processing Budget**: <8ms per frame for analysis + rendering
4. **Memory**: <10MB total for all buffers
5. **Quality Adaptation**: Dynamic quality scaling for performance

## Recommended Audio Processing Optimizations

### 1. Adaptive FFT Configuration
```typescript
class AdaptiveMandalaAnalyzer extends AudioEngine {
  private mandalaConfig = {
    targetFps: 60,
    qualityLevel: 'medium',
    performanceMode: 'auto'
  };
  
  updateFFTSize(performanceMetrics: { currentFps: number; frameTime: number }) {
    if (performanceMetrics.currentFps < 45) {
      this.config.fftSize = 1024; // Reduce quality for performance
    } else if (performanceMetrics.currentFps > 58 && performanceMetrics.frameTime < 5) {
      this.config.fftSize = 4096; // Increase quality if headroom available
    }
  }
}
```

### 2. Frequency Band Preprocessing
```typescript
class MandalaFrequencyProcessor {
  private frequencyBands: Float32Array;
  private bandWeights: Float32Array;
  
  processForMandala(rawFreqData: Uint8Array): MandalaFrequencyData {
    // Convert to 0.0-1.0 range
    const normalized = this.normalizeFrequencyData(rawFreqData);
    
    // Group into perceptually relevant bands
    const bandedData = this.groupIntoBands(normalized, FREQUENCY_BANDS);
    
    // Apply weighting for musical content
    const weightedData = this.applyAWeighting(bandedData);
    
    return {
      radialBands: weightedData,
      peakFrequency: this.findPeakFrequency(normalized),
      totalEnergy: this.calculateRMSEnergy(normalized),
      spectralCentroid: this.calculateSpectralCentroid(normalized)
    };
  }
}
```

### 3. Performance Monitoring Integration
```typescript
class MandalaPerformanceMonitor {
  private metrics = {
    audioAnalysisTime: 0,
    frequencyProcessingTime: 0,
    totalFrameTime: 0,
    droppedFrames: 0
  };
  
  measureAudioProcessing<T>(fn: () => T): T {
    const start = performance.now();
    const result = fn();
    this.metrics.audioAnalysisTime = performance.now() - start;
    return result;
  }
}
```

## Next Steps for Implementation

### Priority 1: Audio Engine Enhancements
1. Implement adaptive FFT sizing based on performance
2. Add frequency band grouping for radial mapping
3. Integrate performance monitoring hooks
4. Add configurable smoothing for different visualization modes

### Priority 2: Data Pipeline Optimization
1. Create `MandalaFrequencyData` interface
2. Implement frequency band preprocessing
3. Add spectral analysis features (centroid, peak detection)
4. Optimize memory allocation patterns

### Priority 3: Performance Adaptation
1. Implement quality scaling based on frame rate
2. Add mobile-specific optimizations
3. Create performance budgeting system
4. Add diagnostic metrics collection

## Technical Specifications Summary

| Component | Current | Mandala Optimized |
|-----------|---------|-------------------|
| FFT Size | Fixed 2048 | Adaptive 1024-8192 |
| Frequency Bins | 1024 | Adaptive 512-4096 |
| Smoothing | 0.8 (heavy) | 0.6 (responsive) |
| Update Rate | 60fps | Adaptive 30-60fps |
| Data Format | Uint8Array[1024] | MandalaFrequencyData |
| Memory Usage | ~1KB | ~5KB (with metadata) |
| Processing Time | <1ms | <3ms (with preprocessing) |

## Conclusion

The current audio engine provides a solid foundation for mandala visualization but requires enhancements for optimal radial frequency mapping. Key improvements include adaptive quality scaling, frequency band preprocessing, and performance monitoring integration.

**Estimated Implementation Time**: 8-12 hours for complete mandala optimization package.

---
*Analysis completed by Web Audio API and Digital Signal Processing Specialist*
*Files analyzed: audioEngine.ts, types.ts, renderer.ts, main.ts*